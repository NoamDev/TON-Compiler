//===--------- TVMScheduler.cpp - Rewrite Reg-forms with S-forms ---------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
///
/// \file
/// Introduce explicit stack manipulation. Rewrite all register forms of
/// instructions with their stack counterparts.
///
//===----------------------------------------------------------------------===//

#include <unordered_map>

#include "MCTargetDesc/TVMMCTargetDesc.h"
#include "TVM.h"
#include "TVMStack.h"
#include "TVMStackBlockInfo.h"
#include "TVMSubtarget.h"
#include "TVMUtilities.h"

#include "llvm/ADT/PostOrderIterator.h"
#include "llvm/ADT/SmallVector.h"
#include "llvm/CodeGen/LiveIntervals.h"
#include "llvm/CodeGen/MachineBlockFrequencyInfo.h"
#include "llvm/CodeGen/MachineDominators.h"
#include "llvm/CodeGen/MachineInstrBuilder.h"
#include "llvm/CodeGen/MachineRegisterInfo.h"
#include "llvm/CodeGen/Passes.h"
#include "llvm/IR/DebugInfoMetadata.h"
#include "llvm/Support/raw_ostream.h"

using namespace llvm;

#define DEBUG_TYPE "tvm-scheduler"

static cl::opt<bool>
    DisableTVMScheduler("disable-tvm-scheduler", cl::Hidden,
                        cl::desc("TVM: Disable scheduling."),
                        cl::init(false));

namespace {

/// The pass makes stack explicit by rewriting Reg-form instructions with S-form
/// and inserting stack manipulation instructions. The rewriting is done in the
/// following stages:
/// 1. Define roads. Roads are equivalence classes for initial and final stack
/// configurations.
/// 2. Define stack configurations for start and end of each basic block. For
/// now we do it arbitrary having the information about live-ins and live-outs.
/// TODO: We should consider to be more flexibe with stack patterns to reduce
/// number of stack manipulations required.
/// 3. Process basic blocks one by one, knowing the initial and final stack
/// configurations and rewriting all Reg-form instructions to S-form.
class TVMScheduler final : public MachineFunctionPass {
public:
  using RegUsage = std::unordered_map<unsigned, unsigned>;
  StringRef getPassName() const override { return "TVM Scheduler"; }

  void getAnalysisUsage(AnalysisUsage &AU) const override {
    AU.addRequired<LiveIntervals>();
    AU.addPreservedID(LiveVariablesID);
    AU.addRequired<MachineLoopInfo>();
    AU.addPreserved<MachineLoopInfo>();
    MachineFunctionPass::getAnalysisUsage(AU);
  }

  bool runOnMachineFunction(MachineFunction &MF) override;

  MachineInstr *optimizeReversible(MachineInstr &MI, const Stack &TheStack);

  /// Calculate required stack manipulations to ship arguments to \par MI.
  /// TODO: Index is a hacky way to work with reverse form of instructions
  /// (e.g. SUBR, STIR, STUXR), it stores LI SlotIndex of the original
  /// definition while the rest parts of the modelling work generated by the
  /// pass SUBR, STIR and so on.
  StackFixup prepareStackFor(MachineInstr &MI, const Stack &StackBefore,
                             SlotIndex Index,
                             const RegUsage& RU);

  /// Calculate stack after \par MI execution.
  /// This fixup is not supposed to be code generated.
  void modelInstructionExecution(const MachineInstr &MI, Stack &StackBefore);

  static char ID; // Pass identification, replacement for typeid
  TVMScheduler() : MachineFunctionPass(ID) {}

private:
  /// Returns if \p I can be scheduled next.
  /// The instruction can be scheduled iff all the incoming virtual registers
  /// are on \p TheStack.
  bool isFeasibleToSchedule(MachineInstr &I, const Stack &TheStack);

  /// Collects info { VR, number of usage }.
  /// Since the pass reorder instructions, it can't rely on live intervals
  /// inside a BB, so LI are reconstructed by LI at the end of BB + RegUsage.
  RegUsage collectUsageInfo(MachineBasicBlock::iterator Begin,
                            MachineBasicBlock::iterator End);

  /// Finds which instruction should be scheduled next having the stack.
  std::pair<MachineInstr *, StackFixup> nextInstruction(MachineBasicBlock::iterator Begin,
                                MachineBasicBlock::iterator End,
                                const Stack &TheStack);

  bool runOnBasicBlocks(MachineFunction &MF, const Stack &StartStack);

  /// Calculate equvalent classes on BB's entry / exit stack configuration
  /// and store them as road numbers in BBInfo.
  void prepareRoads(MachineFunction &MF);

  /// Compute road pattern -- a particular stack configuration used accross
  /// the blocks of the road. The pattern is based on the output stack config
  /// of the block which enters the road first in RPO traversal of the CFG.
  void computeRoadPattern(MachineFunction &MF, unsigned RoadIdx,
                          const Stack &OutStack);

  /// Append \par MMB live-ins to \par vregs
  void gatherBlockLiveIns(MachineBasicBlock &MBB, std::set<unsigned> &vregs);
  /// Append \par MMB live-outs to \par vregs
  void gatherBlockLiveOuts(MachineBasicBlock &MBB, std::set<unsigned> &vregs);

  const DILocalVariable *findDebugValue(const MachineInstr &MI,
                                        unsigned Vreg) const;

  /// Returns true if From -> To branch is a backedge
  bool isBackEdge(const MachineBasicBlock *From,
                  const MachineBasicBlock *To) const;

  TVMFunctionInfo *MFI;
  MachineRegisterInfo *MRI;
  const TargetInstrInfo *TII;
  MachineLoopInfo *Loops;
  LiveIntervals *LIS;

  /// Store requirements on for BB stack configurations
  DenseMap<MachineBasicBlock *, TVMStackBlockInfo> BBInfo;
  unsigned MaxRoads = 0;
  unsigned MaxRoadWidth = 0;
};

} // end anonymous namespace

char TVMScheduler::ID = 0;
INITIALIZE_PASS(TVMScheduler, DEBUG_TYPE, "Stackify register instructions",
                false, false)

FunctionPass *llvm::createTVMScheduler() { return new TVMScheduler(); }

const DILocalVariable *TVMScheduler::findDebugValue(const MachineInstr &MI,
                                                    unsigned Vreg) const {
  auto it = llvm::find_if(*MI.getParent(), [Vreg](const MachineInstr &DI) {
    return DI.isDebugValue() &&
           (DI.getOperand(0).isReg() && DI.getOperand(0).getReg() == Vreg);
  });
  return (it != MI.getParent()->end()) ? it->getDebugVariable() : nullptr;
}

MachineInstr *TVMScheduler::optimizeReversible(MachineInstr &MI,
                                               const Stack &TheStack) {
  MachineInstrBuilder MIB;
  std::unordered_map<unsigned, unsigned> OpcodeMap = {
      {TVM::SUB, TVM::SUBR},   {TVM::STI, TVM::STIR},   {TVM::STU, TVM::STUR},
      {TVM::STIX, TVM::STIXR}, {TVM::STUX, TVM::STUXR}, {TVM::SGT, TVM::SLT},
      {TVM::SGE, TVM::SLE},    {TVM::SLT, TVM::SGT},    {TVM::SLE, TVM::SGE}};
  switch (MI.getOpcode()) {
  case TVM::SUB:
  case TVM::STU:
  case TVM::STI: {
    assert(MI.getOperand(0).isReg() && MI.getOperand(1).isReg() &&
           MI.getOperand(2).isReg() && "Operands must be registers");
    size_t OrigScore = TheStack.position(MI.getOperand(1).getReg()) == 1;
    OrigScore += TheStack.position(MI.getOperand(2).getReg()) == 0;
    size_t RScore = TheStack.position(MI.getOperand(1).getReg()) == 0;
    RScore += TheStack.position(MI.getOperand(2).getReg()) == 1;
    if (RScore > OrigScore) {
      MIB = BuildMI(*MI.getParent(), &MI, MI.getDebugLoc(),
                    TII->get(OpcodeMap.at(MI.getOpcode())),
                    MI.getOperand(0).getReg())
                .addReg(MI.getOperand(2).getReg())
                .addReg(MI.getOperand(1).getReg());
      if (MI.getOpcode() == TVM::STI || MI.getOpcode() == TVM::STU) {
        assert(MI.getOperand(3).isCImm() && "Operand must be an immediate");
        MIB.addCImm(MI.getOperand(3).getCImm());
      }
    } else {
      return nullptr;
    }
    break;
  }
  case TVM::STIX:
  case TVM::STUX: {
    assert(MI.getOperand(0).isReg() && MI.getOperand(1).isReg() &&
           MI.getOperand(2).isReg() && MI.getOperand(3).isReg() &&
           "Operands must be registers");
    size_t OrigScore = TheStack.position(MI.getOperand(1).getReg()) == 2;
    OrigScore += TheStack.position(MI.getOperand(2).getReg()) == 1;
    size_t RScore = TheStack.position(MI.getOperand(1).getReg()) == 1;
    RScore += TheStack.position(MI.getOperand(2).getReg()) == 2;
    if (RScore > OrigScore) {
      MIB = BuildMI(*MI.getParent(), &MI, MI.getDebugLoc(),
                    TII->get(OpcodeMap.at(MI.getOpcode())),
                    MI.getOperand(0).getReg())
                .addReg(MI.getOperand(2).getReg())
                .addReg(MI.getOperand(1).getReg())
                .addReg(MI.getOperand(3).getReg());
    } else {
      return nullptr;
    }
    break;
  }
  case TVM::SGT:
  case TVM::SGE:
  case TVM::SLT:
  case TVM::SLE: {
    assert(MI.getOperand(0).isReg() && MI.getOperand(1).isReg() &&
           "Operands must be registers");
    size_t OrigScore = TheStack.position(MI.getOperand(1).getReg()) == 1;
    OrigScore += TheStack.position(MI.getOperand(2).getReg()) == 0;
    size_t RScore = TheStack.position(MI.getOperand(1).getReg()) == 0;
    RScore += TheStack.position(MI.getOperand(2).getReg()) == 1;
    if (RScore > OrigScore) {
      MIB = BuildMI(*MI.getParent(), &MI, MI.getDebugLoc(),
                    TII->get(OpcodeMap.at(MI.getOpcode())),
                    MI.getOperand(0).getReg())
                .addReg(MI.getOperand(2).getReg())
                .addReg(MI.getOperand(1).getReg());
    } else {
      return nullptr;
    }
    break;
  }
  default:
    return nullptr;
  }
  return MIB.getInstr();
}

bool TVMScheduler::isFeasibleToSchedule(MachineInstr &I,
                                        const Stack &TheStack) {
  for (unsigned i = I.getNumDefs(); i < I.getNumOperands(); ++i) {
    if (I.getOperand(i).isReg() &&
        !TheStack.exist(StackVreg(I.getOperand(i).getReg())))
      return false;
  }
  return true;
}

TVMScheduler::RegUsage
TVMScheduler::collectUsageInfo(MachineBasicBlock::iterator Begin,
                               MachineBasicBlock::iterator End) {
  RegUsage Result;
  for (auto I = Begin; I != End; ++I) {
    for (unsigned i = I->getNumDefs(); i < I->getNumOperands(); ++i) {
      if (I->getOperand(i).isReg())
        Result[I->getOperand(i).getReg()]++;
    }
  }
  return Result;
}

std::pair<MachineInstr *, StackFixup> TVMScheduler::nextInstruction(MachineBasicBlock::iterator Begin,
                                            MachineBasicBlock::iterator End,
                                            const Stack &TheStack) {
  if (Begin == End)
    return {};
  DenseMap<MachineInstr *, unsigned> Costs;
  DenseMap<MachineInstr *, StackFixup> Fixes;
  RegUsage RU = collectUsageInfo(Begin, End);
  SlotIndex Index = LIS->getInstructionIndex(*std::prev(End)).getRegSlot();
  for (auto I = Begin; I != End; ++I) {
    if (!isFeasibleToSchedule(*I, TheStack) || I->isTerminator()) {
      Costs.insert({&*I,
                   std::numeric_limits<unsigned>::max() - !I->isTerminator()});
      continue;
    }
    MachineInstr *Instr = optimizeReversible(*I, TheStack);
    bool RemoveReversible = Instr;
    if (!RemoveReversible)
      Instr = &*I;
    StackFixup Fix = prepareStackFor(*Instr, TheStack, Index, RU);
    unsigned Cost = Fix.cost();
    unsigned NumRegOperands = llvm::count_if(
        Instr->operands(), [](const MachineOperand &Op) { return Op.isReg(); });
    NumRegOperands -= I->getNumDefs();
    if (RemoveReversible) {
      Instr->eraseFromParent();
    }
    if (NumRegOperands) {
      Cost /= NumRegOperands;
      // Prioritize to do nothing rather than reorder
      if (I == Begin)
        Cost -= Cost ? 1 : 0;
    }
    // The expected cost of an instruction with stack argument is 16,
    // so we prioritize it unless we don't need to move a constant.
    else {
      Cost = (I == Begin) ? 15 : 17;
    }
    Costs.insert({&*I, Cost});
    Fixes.insert({&*I, Fix});
  }
  LLVM_DEBUG(dbgs() << "======= SCHEDULLING FOR =======\n"
                    << *Begin->getParent()
                    << "-------------------------------\n"
                    << *Begin << TheStack << "\n"
                    << "-------------------------------\n");
  for (auto el : Costs)
    LLVM_DEBUG(dbgs() << *el.first << "cost: " << el.second << "\n");
  LLVM_DEBUG(dbgs() << "-------------------------------\n");

  auto cheapest = *std::min_element(
      std::begin(Costs), std::end(Costs),
      [](auto left, auto right) { return left.second < right.second; });

  LLVM_DEBUG(dbgs() << "Best to schedule\n"
                    << *cheapest.first << "Cost: " << cheapest.second << "\n"
                    << "-------------------------------\n");
  if (cheapest.first->isTerminator()) {
    SlotIndex Index = LIS->getInstructionIndex(*cheapest.first).getRegSlot();
    std::string PreTermStackStr;
    StackFixup Fix = prepareStackFor(*cheapest.first, TheStack, Index, RU);
    return {cheapest.first, Fix};
  }
  return {cheapest.first, Fixes[cheapest.first]};
}

// Traverse all basic blocks in machine function and rewrite all instructions
// from R-form to S-form. All function arguments are already in stack.
bool TVMScheduler::runOnBasicBlocks(MachineFunction &MF,
                                    const Stack &StartStack) {
  bool Changed = false;

  auto &FirstBB = MF.front();
  BBInfo[&FirstBB].setFixedBegin(StartStack);

  using RPOTType = ReversePostOrderTraversal<MachineFunction *>;
  RPOTType RPOT(&MF);
#if DEBUG_RPOT
  llvm::dbgs() << "RPOT:";
  for (RPOTType::rpo_iterator I = RPOT.begin(), E = RPOT.end(); I != E; ++I) {
    auto MBB = *I;
    llvm::dbgs() << " " << MBB->getNumber();
  }
  llvm::dbgs() << "\n";
#endif
  for (RPOTType::rpo_iterator I = RPOT.begin(), E = RPOT.end(); I != E; ++I) {
    auto MBB = *I;
    auto &bbInfo = BBInfo[MBB];
    auto CurrentStack = bbInfo.fixedBegin(); // start bb stack here

    auto Instr = MBB->begin();
    while (Instr != MBB->end()) {
      if (TVM::isArgument(*Instr) || TVM::isArgumentNum(*Instr)) {
        ++Instr;
        continue;
      }
      MachineInstr *NextI;
      StackFixup Fix;
      std::tie(NextI, Fix) = nextInstruction(Instr, MBB->end(), CurrentStack);
      if (NextI != &*Instr)
        MBB->splice(Instr, MBB, NextI);
      Instr = std::find_if(
          MBB->instr_begin(), MBB->instr_end(),
          [NextI](MachineInstr &Other) { return &Other == NextI; });

#if 0
      llvm::outs() << "************\n";
      llvm::outs() << CurrentStack << "\n";
      llvm::outs() << Fix << "\n";
      llvm::outs() << *NextI;
#endif
      Fix.apply(CurrentStack);
#if 0
      llvm::outs() << CurrentStack << "\n";
      llvm::outs() << "************\n";
#endif
      modelInstructionExecution(*NextI, CurrentStack);
      MachineInstr &MI = *Instr++;
      assert(!TVM::isArgument(MI));

      if (MI.isDebugInstr() || MI.isLabel())
        continue;
    }
    bbInfo.setCalculatedEnd(CurrentStack);
  }
  return Changed;
}

void TVMScheduler::prepareRoads(MachineFunction &MF) {
  MachineBasicBlock &FirstBB = MF.front();

  BBInfo.clear();
  BBInfo.reserve(MF.size());
  for (auto &MBB : MF) {
    BBInfo[&MBB].setMBB(&MBB);
  }

  /// TODO: It's better to encode keep infor about roads with a more expressive
  /// class than unsigned. The suggestion is to use shared_ptr<Stack> instead of
  /// unsigned.
  unsigned curRoad = 1;
  std::deque<MachineBasicBlock *> queueThisRoad;
  queueThisRoad.push_back(&FirstBB);
  BBInfo[&FirstBB].setRoadEnd(curRoad);
  std::deque<MachineBasicBlock *> queueNextRoads;

  auto processSuccessors = [&](MachineBasicBlock *CurBB) {
    auto endRoad = BBInfo[CurBB].roadEnd();
    assert(endRoad && "null CurBB road in processing successors");
    for (auto Succ : CurBB->successors()) {
      auto &CurInfo = BBInfo[Succ];
      auto beginRoad = CurInfo.roadBegin();
      assert((beginRoad == endRoad || !beginRoad) &&
             "Already defined different road");
      if (!beginRoad) {
        CurInfo.setRoadBegin(endRoad);
        queueThisRoad.push_back(Succ);

        // other side of the block
        if (!CurInfo.roadEnd())
          queueNextRoads.push_back(Succ);
      }
    }
  };
  auto processPredecessors = [&](MachineBasicBlock *CurBB) {
    auto beginRoad = BBInfo[CurBB].roadBegin();
    assert(beginRoad && "null CurBB road in processing predecessors");
    for (auto Pred : CurBB->predecessors()) {
      auto &CurInfo = BBInfo[Pred];
      auto endRoad = CurInfo.roadEnd();
      assert((beginRoad == endRoad || !endRoad) &&
             "Already defined different road");
      if (!endRoad) {
        CurInfo.setRoadEnd(beginRoad);
        queueThisRoad.push_back(Pred);

        // other side of the block
        if (!CurInfo.roadBegin())
          queueNextRoads.push_back(Pred);
      }
    }
  };
  do {
    while (!queueThisRoad.empty()) {
      auto CurBB = queueThisRoad.front();
      queueThisRoad.pop_front();
      auto &CurInfo = BBInfo[CurBB];
      if (CurInfo.roadBegin() == curRoad)
        processPredecessors(CurBB);
      if (CurInfo.roadEnd() == curRoad)
        processSuccessors(CurBB);
    }

    ++curRoad;

    while (!queueNextRoads.empty()) {
      auto CurBB = queueNextRoads.front();
      queueNextRoads.pop_front();
      auto &CurInfo = BBInfo[CurBB];
      if (CurInfo.roadBegin() && CurInfo.roadEnd())
        continue;
      assert(!(!CurInfo.roadBegin() && !CurInfo.roadEnd()) &&
             "Both side roads can't be null for block in queueNextRoads");
      if (!CurInfo.roadBegin())
        CurInfo.setRoadBegin(curRoad);
      if (!CurInfo.roadEnd())
        CurInfo.setRoadEnd(curRoad);
      queueThisRoad.push_back(CurBB);
      break;
    }
  } while (!queueThisRoad.empty());

  MaxRoads = curRoad;
}

void TVMScheduler::gatherBlockLiveIns(MachineBasicBlock &MBB,
                                      std::set<unsigned> &vregs) {
  for (unsigned i = 0, e = MRI->getNumVirtRegs(); i != e; ++i) {
    unsigned Reg = TargetRegisterInfo::index2VirtReg(i);
    if (LIS->hasInterval(Reg)) {
      if (LIS->isLiveInToMBB(LIS->getInterval(Reg), &MBB)) {
        vregs.insert(Reg);
      }
    }
  }
}

void TVMScheduler::gatherBlockLiveOuts(MachineBasicBlock &MBB,
                                       std::set<unsigned> &vregs) {
  for (unsigned i = 0, e = MRI->getNumVirtRegs(); i != e; ++i) {
    unsigned Reg = TargetRegisterInfo::index2VirtReg(i);
    if (LIS->hasInterval(Reg)) {
      if (LIS->isLiveOutOfMBB(LIS->getInterval(Reg), &MBB)) {
        vregs.insert(Reg);
      }
    }
  }
}

// TODO: For now it only stackifies function arguments. Extend.
bool TVMScheduler::runOnMachineFunction(MachineFunction &MF) {
  if (DisableTVMScheduler)
    return false;
  LLVM_DEBUG(
      dbgs()
      << "********** Scheduling in accordance with stack data **********\n"
         "********** Function: "
      << MF.getName() << '\n');

  bool Changed = false;
  MFI = MF.getInfo<TVMFunctionInfo>();
  MRI = &MF.getRegInfo();
  TII = MF.getSubtarget<TVMSubtarget>().getInstrInfo();
  Loops = &getAnalysis<MachineLoopInfo>();
  LIS = &getAnalysis<LiveIntervals>();

  MaxRoads = 0;
  MaxRoadWidth = 0;

  prepareRoads(MF);

  MachineBasicBlock &FirstBB = MF.front();
  if (!FirstBB.empty()) {
    auto &ANI = FirstBB.front();

    // Process ARGUMENT_NUM instruction to adjust arguments number on stack.
    if (TVM::isArgumentNum(ANI)) {
      int args = ANI.getOperand(0).getImm();
      for (int i = 0; i < args; i++)
        MFI->addParam(MVT::i64);
    }
  }

  size_t NumArgs = MFI->numParams();
  Stack StartStack(MF, NumArgs);

  // Handle ARGUMENTS first to ensure that they get the designated numbers.
  for (MachineBasicBlock::iterator I = FirstBB.begin(), E = FirstBB.end();
       I != E;) {
    MachineInstr &MI = *I++;
    if (!TVM::isArgument(MI))
      break;
    unsigned Reg = MI.getOperand(0).getReg();
    assert(!MFI->isVRegStackified(Reg));
    unsigned ArgNo = NumArgs - MI.getOperand(1).getCImm()->getZExtValue() - 1;
    StartStack.set(ArgNo, StackVreg(Reg, findDebugValue(MI, Reg)));
  }

  Changed |= runOnBasicBlocks(MF, StartStack);

  return Changed;
}

void TVMScheduler::computeRoadPattern(MachineFunction &MF, unsigned RoadIdx,
                                      const Stack &OutStack) {
  std::set<MachineBasicBlock *> BBs, SinkBBs;
  for (auto &MBB : MF) {
    auto &Info = BBInfo[&MBB];
    if (Info.roadBegin() == RoadIdx) {
      SinkBBs.insert(&MBB);
      BBs.insert(&MBB);
    }
    if (Info.roadEnd() == RoadIdx)
      BBs.insert(&MBB);
  }

#if DEBUG_ROADS
  llvm::dbgs() << "Road " << RoadIdx << ":";
  for (auto MBB : BBs) {
    auto &Info = BBInfo[MBB];
    llvm::dbgs() << " ";
    if (Info.roadBegin() == RoadIdx)
      llvm::dbgs() << "-";
    llvm::dbgs() << MBB->getNumber();
    if (Info.roadEnd() == RoadIdx)
      llvm::dbgs() << "-";
  }
  llvm::dbgs() << "\n";
#endif

  Stack RoadPattern(MF, 0);
  if (SinkBBs.size() == 1 && (*SinkBBs.begin())->succ_size() == 0) {
    auto *MBB = *SinkBBs.begin();
    std::set<unsigned> Regs;
    gatherBlockLiveIns(*MBB, Regs);
    gatherBlockLiveOuts(*MBB, Regs);
    for (auto Reg : Regs)
      RoadPattern.addDef(Reg, nullptr);
  } else {
    std::set<unsigned> Regs;
    for (auto MBB : BBs) {
      auto &Info = BBInfo[MBB];
      if (Info.roadBegin() == RoadIdx)
        gatherBlockLiveIns(*MBB, Regs);
      if (Info.roadEnd() == RoadIdx)
        gatherBlockLiveOuts(*MBB, Regs);
    }
    // Push remaining road pattern registers on top of the output stack
    // of the block which enters the road first
    for (auto Reg : OutStack)
      Regs.erase(Reg.VirtReg);
    RoadPattern = OutStack;
    for (auto Reg : Regs)
      RoadPattern.addDef(Reg, nullptr);
  }

  for (auto MBB : BBs) {
    auto &Info = BBInfo[MBB];
    if (Info.roadBegin() == RoadIdx) {
      Info.setFixedBegin(RoadPattern.filteredByLiveIns(*MBB, *LIS));
      MFI->setStackModelBBComment(MBB, Info.fixedBegin().toString());
    }
    if (Info.roadEnd() == RoadIdx)
      Info.setFixedEnd(RoadPattern);
  }
}

/// Model stack for a single instruction.
StackFixup TVMScheduler::prepareStackFor(MachineInstr &MI,
                                         const Stack &StackBefore,
                                         SlotIndex Index,
                                         const RegUsage &RU) {
  if (MI.isImplicitDef())
    return {};

  if (MI.getOpcode() == TVM::HIDDENSTACK) {
    auto Result = MI.getOperand(0);
    auto Operand = MI.getOperand(1);
    assert(Result.isReg() && Operand.isCImm() &&
           "Unexpected instruction format");
    return StackFixup::DiffForHiddenStack(
        StackBefore, Operand.getCImm()->getZExtValue(), Result.getReg());
  }

  auto *MBB = MI.getParent();

#ifndef NDEBUG
  {
    SmallVector<StackVreg, 32> Vregs(
        llvm::make_filter_range(StackBefore, [](StackVreg vreg) {
          return vreg.VirtReg != TVMFunctionInfo::UnusedReg;
        }));

    llvm::sort(Vregs.begin(), Vregs.end());
#if 0
    for(auto &VR : Vregs)
      llvm::outs() << VR.VirtReg << ", ";
    llvm::outs() << "\n";
#endif
    auto it = std::unique(Vregs.begin(), Vregs.end());
    //assert(it == Vregs.end() && "Vreg duplicates found in stack");
  }
#endif

  // TODO: We can do it inplace.
  Stack TheStack = StackBefore.filteredByMIdefs(MI);

  size_t NumOperands = MI.getNumOperands();

  // FIXME: wrong assumption. There is no function scope in TVM so RET
  // terminates the current continuation - not necessary a function.
  if (MI.isReturn()) {
    if (NumOperands == 0)
      return StackFixup::DiffForReturn(TheStack);
    else if (NumOperands == 1) {
      auto Op = MI.getOperand(0);
      auto Reg = Op.isUndef() ? TVMFunctionInfo::UnusedReg : Op.getReg();
      return StackFixup::DiffForReturn(TheStack, Reg);
    } else {
      SmallVector<unsigned, 16> RetRegs;
      RetRegs.reserve(NumOperands);
      for (const auto &Op : MI.operands())
        RetRegs.push_back(Op.isUndef() ? TVMFunctionInfo::UnusedReg
                                       : Op.getReg());
      return StackFixup::DiffForReturnMulti(TheStack, RetRegs);
    }
  }

  bool IsLast = MI.isTerminator() || !MI.getNextNode();
  if (IsLast && MBB->succ_size()) {
    if (!BBInfo[MBB].isFixedEnd()) {
      size_t RegsToConsume = 0;
      if (MI.getOpcode() == TVM::JMPX)
        RegsToConsume = 1;
      else if (MI.getOpcode() == TVM::IFJMP || MI.getOpcode() == TVM::IFNOTJMP)
        RegsToConsume = 2;
      else if (MI.getOpcode() == TVM::IFELSE)
        RegsToConsume = 3;
      auto OutStack = TheStack;
      OutStack.consumeArguments(RegsToConsume);
      computeRoadPattern(*MBB->getParent(), BBInfo[MBB].roadEnd(), OutStack);
      assert(BBInfo[MBB].isFixedEnd());
#if DEBUG_PATTERN
      llvm::dbgs() << "BB #" << MBB->getNumber() << " has entered the road\n";
      llvm::dbgs() << "OutStack  " << OutStack << "\n";
      auto AfterTermStack = BBInfo[MBB].fixedEnd();
      llvm::dbgs() << "FixedEnd  " << AfterTermStack << "\n";
      auto NeedStack = AfterTermStack.withArgs(MIArgs(MI, *LIS, Index, RU));
      NeedStack.filterByImpDefs(TheStack);
      llvm::dbgs() << "NeedStack " << NeedStack << "\n";
#endif
    }

    // For terminator instruction we need to prepare stack as
    //  dst road pattern plus required arguments
    auto AfterTermStack = BBInfo[MBB].fixedEnd();
    auto NeedStack = AfterTermStack.withArgs(MIArgs(MI, *LIS, Index, RU));
    NeedStack.filterByImpDefs(TheStack);
    auto Fix = NeedStack - TheStack;
    return Fix;
  } else {
    return StackFixup::DiffForArgs(TheStack, MIArgs(MI, *LIS, Index, RU),
                                   MI.isCommutable());
  }
}

void TVMScheduler::modelInstructionExecution(const MachineInstr &MI,
                                             Stack &StackBefore) {
  if (MI.isImplicitDef())
    return;
  size_t NumDefs = MI.getNumDefs();
  size_t NumStackOperands = llvm::count_if(
      MI.uses(), [](const MachineOperand &MO) { return MO.isReg(); });
  unsigned NumToConsume = NumStackOperands;
#ifndef NDEBUG
  // Let's ensure that consumed registers are used in instruction
  // TODO: Doesn't cover numerous corner cases. Covering them would require to
  // reimplement consumption under NDEBUG or extending consumption interface.
  auto revUses = reverse(MI.uses());
  for (unsigned I = 0; I < NumToConsume; I++) {
    if (MI.isCommutable()) {
      auto regUse = llvm::find_if(revUses, [&](const MachineOperand &Op) {
        return Op.isReg() && StackBefore.reg(I) == Op.getReg();
      });
      assert(regUse != revUses.end() &&
             "Consuming register not used in instruction");
    } else {
      auto regUse = llvm::find_if(
          revUses, [&](const MachineOperand &Op) { return Op.isReg(); });
      assert(regUse != revUses.end() &&
             "Consuming register not used in instruction");

      revUses = llvm::make_range(++regUse, revUses.end());
    }
  }
#endif
  NumToConsume -= llvm::count_if(MI.uses(), [](const MachineOperand &Op) {
                                 return Op.isReg() && Op.isUndef();
                                 });
  StackBefore.consumeArguments(NumToConsume);
  for (size_t OpNo = 0; OpNo < NumDefs; ++OpNo) {
    const auto &Operand = MI.getOperand(OpNo);
    assert(Operand.isReg() && "Def must be a register");
    StackBefore.addDef(Operand.getReg(), findDebugValue(MI, Operand.getReg()));
  }
}
